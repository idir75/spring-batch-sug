<?xml version="1.0" encoding="UTF-8"?>
<!-- $Id$ -->
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xmlns:batch="http://www.springframework.org/schema/batch"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
      http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
      http://www.springframework.org/schema/batch http://www.springframework.org/schema/batch/spring-batch-2.1.xsd">

  <import resource="classpath:fr/sug/springbatch/example/implementations-context.xml"/>

  <context:annotation-config/>
  <context:component-scan base-package="fr.sug.springbatch"/>

  <!-- parent -->
  <batch:job id="jobBean" abstract="true">
    <batch:listeners>
      <batch:listener ref="jobListener"/>
    </batch:listeners>
  </batch:job>

  <!-- Notre Job est composé de 2 steps. -->
  <batch:job id="jobExemple" parent="jobBean">
    <!-- Le premier step est un exemple de Tasklet. Il ne fait qu'afficher l'heure. -->
    <batch:step id="initialStep">
      <batch:tasklet ref="initialTasklet"/>
      <batch:next on="*" to="recipeStep"/>
    </batch:step>
    <!-- Le second step est un exemple de Tasklet de type chunk.
         Il met en oeuvre un traitement par lots en branchant le reader, le processor et le writer ensemble.
    -->
    <batch:step id="recipeStep">
      <batch:tasklet>
        <batch:chunk reader="recipesReader" writer="recipesWriter"
                     processor="recipesProcessor"
                     commit-interval="${job.commit.interval}">
          <batch:streams>
            <batch:stream ref="recipeExcludeWriter"/>
          </batch:streams>
        </batch:chunk>
        <batch:listeners>
          <batch:listener ref="stepRecipeExecutionListener"/>
        </batch:listeners>
      </batch:tasklet>
    </batch:step>
  </batch:job>

  <!-- Le reader a pour responsabilité de lire un élément.
       Ici : un objet recipe. Notre reader utilise une implémentation de lecture XML déjà fournie par Spring Batch.
  -->
  <bean id="recipesReader" class="org.springframework.batch.item.xml.StaxEventItemReader" scope="step">
    <property name="resource" value="#{jobParameters[recipes]}"/>
    <property name="fragmentRootElementName" value="RECIPE"/>
    <property name="unmarshaller" ref="recipeMarshaller"/>
  </bean>

  <!-- Le processor a pour responsabilité de, potentiellement :
       - transformer un objet avant traitement
       - rejeter un objet ou non
       Notre processeur est un composite, c.a.d qu'il chaîne 2 implémentations de processor.
  -->
  <bean id="recipesProcessor" class="org.springframework.batch.item.support.CompositeItemProcessor">
    <property name="delegates">
      <list>
        <bean class="fr.sug.springbatch.example.processor.IdProcessor"/>
        <bean class="fr.sug.springbatch.example.processor.RecipeProcessor"/>
      </list>
    </property>
  </bean>

  <!-- Le write a pour responsabilité d'écrire un lot (chunk) d'objets.
       Il s'agit ici d'une implémentation custom. de writer
  -->
  <bean id="recipesWriter" class="fr.sug.springbatch.example.writer.RecipeItemWriter">
    <property name="dataSource" ref="dataSource"/>
    <property name="sqlQueries" ref="sqlQueries"/>
  </bean>

  <!-- Le step execution listener est à l'écoute des différents évènements survenant pendant le step
       En l'occurence : les rejets.
       Ce listener est une implémentation custom. Il délègue à un writer l'écriture de l'objet rejeté.
  -->
  <bean id="stepRecipeExecutionListener" class="fr.sug.springbatch.example.listener.StepRecipeExecutionListener">
    <property name="recipeExcludeWriter" ref="recipeExcludeWriter"/>
  </bean>

  <!-- Writer d'objets rejetés.
       Ré-utilise une implémentation fournie par Spring Batch pour écrire un objet dans un fichier texte.
  -->
  <bean id="recipeExcludeWriter" class="org.springframework.batch.item.file.FlatFileItemWriter">
    <property name="resource" value="file:///tmp/sug/recipesexcludes.txt"/>
    <property name="lineAggregator">
      <bean class="fr.sug.springbatch.example.writer.RecipeExcludeLineAggregator"/>
    </property>
  </bean>


  <!-- Job lecture de fichier texte maître-détail.
Il s'agit du même job que précédemment, mais on a remplacé le reader XML
par le reader de fichier texte maître détail. -->

  <batch:job id="jobMasterDetail" parent="jobBean">
    <batch:step id="jobMasterDetailMainStep">
      <batch:tasklet>
        <batch:chunk reader="masterDetailRecipeReader" writer="recipesWriter"
                     processor="recipesProcessor"
                     commit-interval="${job.commit.interval}">
          <!-- On doit déclarer ici tous les ItemReader et ItemWriter qui participent au chunk
mais qui ne sont pas déjà déclarés dans le chunk. -->
          <batch:streams>
            <batch:stream ref="masterDetailTextReader"/>
          </batch:streams>
        </batch:chunk>
      </batch:tasklet>
    </batch:step>
  </batch:job>

  <!-- Reader custom qui donne des objets Recipe. Pour cela, il a besoin de lire plusieurs lignes du fichier texte
       (une ligne maître et N lignes détail). La lecture de ces lignes sont déléguées à un ItemReader déjà implémenté
       dans Spring Batch. -->
  <bean id="masterDetailRecipeReader"
        class="fr.sug.springbatch.example.masterdetail.MasterDetailReader"
        scope="step">
    <property name="delegate" ref="masterDetailTextReader"/>
  </bean>

  <!-- Notre fichier maître détail est un fichier texte à champs séparés par des point-virgule. Pour le lire, on
       utilise l'implémentation déjà fournie par Spring Batch pour lire des fichiers plats. -->
  <bean id="masterDetailTextReader"
        class="org.springframework.batch.item.file.FlatFileItemReader"
        scope="step">
    <!-- Chemin d'accès du fichier : -->
    <property name="resource" value="#{jobParameters[recipes]}"/>

    <!-- Objet qui va traiter chaque ligne du fichier : -->
    <property name="lineMapper">
      <bean class="org.springframework.batch.item.file.mapping.DefaultLineMapper">

        <!-- Comment va-t-on découper la ligne en colonnes ? Avec cet objet : -->
        <property name="lineTokenizer" ref="csvTokenizer"/>

        <!-- Comment va-t-on convertir cet ensemble de colonnes en un objet ?
             Ici on ne fait pas de conversion particulière, on veut juste obtenir une représentation brute
             des champs (objet FieldSet). -->
        <property name="fieldSetMapper">
          <bean class="org.springframework.batch.item.file.mapping.PassThroughFieldSetMapper"/>
        </property>
      </bean>
    </property>
  </bean>
  <!-- Cet objet divise la ligne en champs, les champs étant séparés par le caractère ';' -->
  <bean id="csvTokenizer"
        class="org.springframework.batch.item.file.transform.DelimitedLineTokenizer">
    <property name="delimiter" value=";"/>
  </bean>
</beans>
